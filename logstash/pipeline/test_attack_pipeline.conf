input{
    file{
        path => "/var/log/modsecurity/modsec_audit.log"
        codec => json
    }
}

filter{

    if [transaction] {
        mutate {
            rename => {
            "[transaction][time]" => "transaction_time"
            "[transaction][transaction_id]" => "transaction_id"
            }
        }

        date {
            match => ["transaction_time", "dd/MMM/yyyy:HH:mm:ss.SSSSSS Z"]
            target => "@timestamp"
        }
    }

    if [request] {

        # Extracting the request line
        grok {
            match => {
                "[request][request_line]" => "%{WORD:http_method} %{URIPATHPARAM:request_path}(?:\?%{GREEDYDATA:request_query})? %{WORD:request_protocol}"
            }
        }

        mutate {
            lowercase => ["http_method", "request_protocol"]
        }

        # check if http_method is get or post and adjust request_body accordingly
        if [http_method] == "get" {
            if [request_query] {
                mutate { copy => { "request_query" => "request_body" } }
            } else {
                mutate { add_field => { "request_body" => "" } }
            }

        } else if [http_method] == "post" {

            if [request][body][0] {
                mutate { rename => { "[request][body][0]" => "request_body" } }

            } else if [request][fake_body] {
                mutate { add_field => { "request_body" => "%{[request][fake_body]}" } }
            } else {
                mutate { add_field => { "request_body" => "" } }
            }

        } else {
            mutate { add_field => { "request_body" => "" } }
        }

        #  finishing the request body functionality
        urldecode {
            field => "request_body"
        }

        # Extracting the request headers
        mutate {
            rename => {
                "[request][headers][User-Agent]" => "user_agent"
                "[response][headers][Content-Length]" => "content_length"
            }
        }
    }

    if [response] {
        mutate {
            rename => {"[response][status]" => "response_status_code"}
        }
    }

    if [audit_data][messages] {
        # Extracting the audit_data messages
        # 1. Extracting the attack type
        # 2. Extracting the rules
            # 2.1 Extracting the paranoia level
            # 2.2 Extracting the severity
            # 2.3 rule id
        # 3. wieght
        # 4. Extracting the anomoly score
        # 5. Extracting the threshold
        ruby {
            code => '
                messages = event.get("[audit_data][messages]")

                if messages.nil? || !messages.is_a?(Array) || messages.empty?
                    event.tag("_missing_audit_messages")
                end

                attack_type = []
                rules = []
                wieght = 0
                anomaly_score = 0
                threshold = 0

                # define attack type
                if messages.is_a?(Array)
                    messages.each do |message|
                        # Match attack type
                        tag_message = message.match(/tag\s"attack-(\w*)"/)

                        if tag_message && ["sqli", "lfi"].include?(tag_message[1].downcase)
                            attack_type << tag_message[1].downcase
                        end
                    end
                    attack_type.uniq!
                end

                # define rules
                if messages.is_a?(Array)
                    messages.each do |message|
                        message_type = message.match(/tag\s"(attack)-[a-z]*"/)
                        rule_id = message.match(/id\s"(\d*)"/)
                        paranoia_level = message.match(/paranoia-level\/(\d)/)
                        severity = message.match(/severity\s"(\w*)"/)
                        audit_data = message.match(/\[msg\s"([^"]+)"\]/)
                        

                        if message_type && message_type[1] == "attack"
                            if rule_id && rule_id[1] && paranoia_level && paranoia_level[1] && severity && severity[1]
                                rules << {
                                    "rule_id" => rule_id[1],
                                    "paranoia_level" => paranoia_level[1],
                                    "severity" => severity[1],
                                    "audit_data" => audit_data ? audit_data[1] : nil
                                }
                            end
                        end
                    end
                end

                # define wieght
                if messages.is_a?(Array)
                    messages.each do |message|
                        wieght_match = message.match(/detection=(\d+)/)

                        if wieght_match.nil? || wieght_match[1].nil?
                            event.tag("_missing_wieght_match")
                        else 
                            wieght += wieght_match[1].to_i
                        end
                    end
                end

                # define anomaly score
                if messages.is_a?(Array)
                    messages.each do |message|
                        anomaly_score_match = message.match(/Total\sScore:\s(\d+)/)

                        if anomaly_score_match && anomaly_score_match[1]
                            anomaly_score += anomaly_score_match[1].to_i
                        end
                    end
                end

                # define threshold
                if messages.is_a?(Array)
                    messages.each do |message|
                        threshold_match = message.match(/Inbound Scores:.*?threshold=(\d+)/)

                        if threshold_match && threshold_match[1]
                            threshold += threshold_match[1].to_i
                        end
                    end
                end


                event.set("attack_type", attack_type)
                event.set("rules", rules)
                event.set("wieght", wieght)
                event.set("anomaly_score", anomaly_score)
                event.set("threshold", threshold)
            '
        }

        mutate {
            rename => {
                "[response][audit_data][action][intercepted]" => "intercepted"
            }
        }
    }

    # add file relevant information
    if [uploads][info] {

        grok {
            match => {
                "[uploads][info][0][file_name]" => "%{DATA:upload_file_name}\.%{WORD:upload_file_extension}"
            }
        }

        mutate {
            rename => {
                "[uploads][info][0][file_size]" => "upload_file_size"
            }
        }
    }

    mutate {
        add_field => {
            "target" => 0
        }
    }
    # convert possible fields to integers
    mutate {
        
        convert => {
            "content_length" => "integer"
            "response_status_code" => "integer"
            "anomaly_score" => "integer"
            "threshold" => "integer"
            "wieght" => "integer"
            "upload_file_size" => "integer"
        }
    }

    if ![content_length] or [content_length] <= 1 {
        drop { }
    }
    if [request_path] == "/css*" or [request_path] == "/js*" {
        drop { }
    }
    if [request_path] == "/healthz" {
            drop { }
    }

    # Remove the original fields to avoid duplication
    mutate {
    remove_field => [
      "[event][original]",
      "transaction",   
      "request",       
      "response",     
      "uploads",      
      "audit_data"    
    ]
  }
}

output{
    stdout { codec => rubydebug }
    elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "scripting_%{+YYYY.MM.dd.HH}"
        ssl_enabled => false
        data_stream => false
    }
}
